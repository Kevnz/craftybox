// Generated by CoffeeScript 1.3.1
(function() {
  var b2AABB, b2Body, b2BodyDef, b2CircleShape, b2ContactListener, b2DebugDraw, b2Fixture, b2FixtureDef, b2MassData, b2PolygonShape, b2Vec2, b2World, b2WorldManifold, _ref, _ref1, _ref2;

  b2Vec2 = Box2D.Common.Math.b2Vec2;

  _ref = Box2D.Dynamics, b2BodyDef = _ref.b2BodyDef, b2Body = _ref.b2Body, b2FixtureDef = _ref.b2FixtureDef, b2Fixture = _ref.b2Fixture, b2World = _ref.b2World, b2DebugDraw = _ref.b2DebugDraw, b2ContactListener = _ref.b2ContactListener;

  _ref1 = Box2D.Collision, b2AABB = _ref1.b2AABB, b2WorldManifold = _ref1.b2WorldManifold, (_ref2 = _ref1.Shapes, b2MassData = _ref2.b2MassData, b2PolygonShape = _ref2.b2PolygonShape, b2CircleShape = _ref2.b2CircleShape);

  /*
  # #Crafty.Box2D
  # @category Physics
  # Dealing with Box2D
  */


  Crafty.extend({
    Box2D: (function() {
      /*
          PRIVATE
      */

      var _SCALE, _setContactListener, _setDebugDraw, _toBeRemoved, _world;
      _SCALE = 30;
      /*
          # #Crafty.Box2D.world
          # @comp Crafty.Box2D
          # This will return the Box2D world object through a getter,
          # which is a container for bodies and joints.
          # It will have 0 gravity when initialized.
          # Gravity can be set through a setter:
          # Crafty.Box2D.gravity = {x: 0, y:10}
      */

      _world = null;
      /*
          A list of bodies to be destroyed in the next step. Usually during
          collision step, it's bad to destroy bodies.
      */

      _toBeRemoved = [];
      /* 
      Setting up contact listener to notify the concerned entities
      based on the ids in their body's user data that we set during
      the construction of the body. We don't keep track of the contact
      but let the entities handle the collision.
      */

      _setContactListener = function() {
        var contactListener;
        contactListener = new b2ContactListener;
        contactListener.BeginContact = function(contact) {
          var contactPoints, entityIdA, entityIdB, manifold;
          entityIdA = contact.GetFixtureA().GetBody().GetUserData();
          entityIdB = contact.GetFixtureB().GetBody().GetUserData();
          manifold = new b2WorldManifold();
          contact.GetWorldManifold(manifold);
          contactPoints = manifold.m_points;
          Crafty(entityIdA).trigger("BeginContact", {
            points: contactPoints,
            targetId: entityIdB
          });
          return Crafty(entityIdB).trigger("BeginContact", {
            points: contactPoints,
            targetId: entityIdA
          });
        };
        contactListener.EndContact = function(contact) {
          var entityIdA, entityIdB;
          entityIdA = contact.GetFixtureA().GetBody().GetUserData();
          entityIdB = contact.GetFixtureB().GetBody().GetUserData();
          Crafty(entityIdA).trigger("EndContact");
          return Crafty(entityIdB).trigger("EndContact");
        };
        return _world.SetContactListener(contactListener);
      };
      _setDebugDraw = function() {
        var canvas, debugDraw;
        if (Crafty.support.canvas) {
          canvas = document.createElement("canvas");
          canvas.id = "Box2DCanvasDebug";
          canvas.width = Crafty.viewport.width;
          canvas.height = Crafty.viewport.height;
          canvas.style.position = 'absolute';
          canvas.style.left = "0px";
          canvas.style.top = "0px";
          Crafty.stage.elem.appendChild(canvas);
          debugDraw = new b2DebugDraw();
          debugDraw.SetSprite(canvas.getContext('2d'));
          debugDraw.SetDrawScale(_SCALE);
          debugDraw.SetFillAlpha(0.7);
          debugDraw.SetLineThickness(1.0);
          debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_joinBit);
          return _world.SetDebugDraw(debugDraw);
        }
      };
      return {
        /*
            PUBLIC
        */

        /*
            # #Crafty.Box2D.debug
            # @comp Crafty.Box2D
            # This will determine whether to use Box2D's own debug Draw
        */

        debug: false,
        /*
            # #Crafty.Box2D.init
            # @comp Crafty.Box2D
            # @sign public void Crafty.Box2D.init(params)
            # @param options: An object contain settings for the world
            # Create a Box2D world. Must be called before any entities
            # with the Box2D component can be created
        */

        init: function(options) {
          var doSleep, gravityX, gravityY, _ref3, _ref4, _ref5, _ref6,
            _this = this;
          gravityX = (_ref3 = options != null ? options.gravityX : void 0) != null ? _ref3 : 0;
          gravityY = (_ref4 = options != null ? options.gravityY : void 0) != null ? _ref4 : 0;
          _SCALE = (_ref5 = options != null ? options.scale : void 0) != null ? _ref5 : 30;
          doSleep = (_ref6 = options != null ? options.doSleep : void 0) != null ? _ref6 : true;
          _world = new b2World(new b2Vec2(gravityX, gravityY), doSleep);
          this.__defineGetter__('world', function() {
            return _world;
          });
          this.__defineSetter__('gravity', function(v) {
            var body, _results;
            _world.SetGravity(new b2Vec2(v.x, v.y));
            body = _world.GetBodyList();
            _results = [];
            while (body != null) {
              body.SetAwake(true);
              _results.push(body = body.GetNext());
            }
            return _results;
          });
          this.__defineGetter__('gravity', function() {
            return _world.GetGravity();
          });
          this.__defineGetter__('SCALE', function() {
            return _SCALE;
          });
          _setContactListener();
          Crafty.bind("EnterFrame", function() {
            var body, _i, _len;
            _world.Step(1 / Crafty.timer.getFPS(), 10, 10);
            for (_i = 0, _len = _toBeRemoved.length; _i < _len; _i++) {
              body = _toBeRemoved[_i];
              _world.DestroyBody(body);
            }
            if (_this.debug) {
              _world.DrawDebugData();
            }
            return _world.ClearForces();
          });
          return _setDebugDraw();
        },
        /*
            #Crafty.Box2D.destroy
            @comp Crafty.Box2D
            @sign public void Crafty.Box2D.destroy([b2Body body])
            @param body - The body to be destroyed. Destroy all if none
            Destroy all the bodies in the world. Internally, add to a list to destroy
            on the next step to avoid collision step.
        */

        destroy: function(body) {
          var _results;
          if (body != null) {
            return _toBeRemoved.push(body);
          } else {
            body = _world.GetBodyList();
            _results = [];
            while (body != null) {
              _world.DestroyBody(body);
              _results.push(body = body.GetNext());
            }
            return _results;
          }
        }
      };
    })()
  });

  /*
  # #Box2D
  # @category Physics
  # Creates itself in a Box2D World. Crafty.Box2D.init() will be automatically called
  # if it is not called already (hence the world element doesn't exist).
  # In order to create a Box2D object, a body definition of position and dynamic is need.
  # The world will use this bodyDef to create a body. A fixture definition with geometry,
  # friction, density, etc is also required. Then create shapes on the body.
  # The body will be created during the .attr call instead of init.
  */


  Crafty.c("Box2D", (function() {
    /*
      PRIVATE
    */

    var _body, _circle, _createBody, _entity, _fixDef, _rectangle;
    _entity = null;
    _body = null;
    _fixDef = null;
    _createBody = function(attrs) {
      var SCALE, bodyDef, h, w, _ref3, _ref4, _ref5, _ref6, _ref7;
      SCALE = Crafty.Box2D.SCALE;
      bodyDef = new b2BodyDef;
      bodyDef.type = (attrs.dynamic != null) && attrs.dynamic ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
      bodyDef.position.Set(attrs.x / SCALE, attrs.y / SCALE);
      _entity.body = Crafty.Box2D.world.CreateBody(bodyDef);
      _entity.body.SetAwake(attrs.dynamic != null);
      _entity.body.SetUserData(_entity[0]);
      _fixDef = _fixDef != null ? _fixDef : new b2FixtureDef;
      _fixDef.density = (_ref3 = attrs.density) != null ? _ref3 : 1.0;
      _fixDef.friction = (_ref4 = attrs.friction) != null ? _ref4 : 0.5;
      _fixDef.restitution = (_ref5 = attrs.restitution) != null ? _ref5 : 0.2;
      if (attrs.r != null) {
        return _circle(attrs.r);
      } else if ((attrs.w != null) || (attrs.h != null)) {
        w = (_entity.w = (_ref6 = attrs.w) != null ? _ref6 : attrs.h) / SCALE;
        h = (_entity.h = (_ref7 = attrs.h) != null ? _ref7 : attrs.w) / SCALE;
        return _rectangle(w, h);
      }
    };
    _circle = function(radius) {
      var SCALE;
      if (!(_entity.body != null)) {
        return _entity;
      }
      SCALE = Crafty.Box2D.SCALE;
      if (_entity.body.GetFixtureList() != null) {
        _entity.body.DestroyFixture(_entity.body.GetFixtureList());
      }
      _entity._w = _entity._h = radius * 2;
      _fixDef.shape = new b2CircleShape(radius / SCALE);
      _fixDef.shape.SetLocalPosition(new b2Vec2(_entity.w / SCALE / 2, _entity.h / SCALE / 2));
      _entity.body.CreateFixture(_fixDef);
      return _entity;
    };
    _rectangle = function(w, h) {
      var SCALE;
      if (!(_entity.body != null)) {
        return _entity;
      }
      h = h != null ? h : w;
      SCALE = Crafty.Box2D.SCALE;
      if (_entity.body.GetFixtureList() != null) {
        _entity.body.DestroyFixture(_entity.body.GetFixtureList());
      }
      _fixDef.shape = new b2PolygonShape;
      _fixDef.shape.SetAsOrientedBox(w / 2, h / 2, new b2Vec2(w / 2, h / 2));
      _entity.body.CreateFixture(_fixDef);
      return _entity;
    };
    return {
      /*
        PUBLIC
      */

      /*
        #.body
        @comp Box2D
        The `b2Body` from Box2D, created by `Crafty.Box2D.world` during `.attr({x, y})` call.
        Shape can be attached to it if more params added to `.attr` call, or through
        `.circle`, `.rectangle`, or `.polygon` method.
      */

      body: null,
      init: function() {
        var SCALE,
          _this = this;
        _entity = this;
        this.addComponent("2D");
        if (!(Crafty.Box2D.world != null)) {
          Crafty.Box2D.init();
        }
        SCALE = Crafty.Box2D.SCALE;
        /*
            Box2D entity is created by calling .attr({x, y, w, h}) or .attr({x, y, r}).
            That funnction triggers "Change" event for us to set box2d attributes.
        */

        this.bind("Change", function(attrs) {
          if (!(attrs != null)) {
            return;
          }
          if ((attrs.x != null) && (attrs.y != null)) {
            return _createBody(attrs);
          }
        });
        this.bind("Move", function(_arg) {
          var _h, _w, _x, _y;
          _x = _arg._x, _y = _arg._y, _w = _arg._w, _h = _arg._h;
          if (!(_this.body != null)) {

          }
          /*if _x isnt @x or _y isnt @y
            #@body.SetAwake(true)
            @body.SetPosition(new b2Vec2(@x/SCALE, @y/SCALE))
          */

        });
        /*
            Update the entity by using Box2D's attributes.
        */

        this.bind("EnterFrame", function() {
          var angle, pos;
          if ((_this.body != null) && _this.body.IsAwake()) {
            pos = _this.body.GetPosition();
            angle = Crafty.math.radToDeg(_this.body.GetAngle());
            if (pos.x * SCALE !== _this.x) {
              _this.x = pos.x * SCALE;
            }
            if (pos.y * SCALE !== _this.y) {
              _this.y = pos.y * SCALE;
            }
            if (angle !== _this.rotation) {
              return _this.rotation = angle;
            }
          }
        });
        /*
            Add this body to a list to be destroyed on the next step.
            This is to prevent destroying the bodies during collision.
        */

        return this.bind("Remove", function() {
          if (_this.body != null) {
            return Crafty.Box2D.destroy(_this.body);
          }
        });
      },
      /*
        #.circle
        @comp Box2D
        @sign public this .circle(Number radius)
        @param radius - The radius of the circle to create
        Attach a circle shape to entity's existing body.
        @example 
        ~~~
        this.attr({x: 10, y: 10, r:10}) // called internally
        this.attr({x: 10, y: 10}).circle(10) // called explicitly
        ~~~
      */

      circle: _circle,
      /*
        #.rectangle
        @comp Box2D
        @sign public this .rectangle(Number w, Number h)
        @param w - The width of the rectangle to create
        @param h - The height of the rectangle to create
        Attach a rectangle or square shape to entity's existing body.
        @example 
        ~~~
        this.attr({x: 10, y: 10, w:10, h: 15}) // called internally
        this.attr({x: 10, y: 10}).rectangle(10, 15) // called explicitly
        this.attr({x: 10, y: 10}).rectangle(10, 10) // a square
        this.attr({x: 10, y: 10}).rectangle(10) // also square!!!
        ~~~
      */

      rectangle: _rectangle,
      /*
        #.hit
        @comp Box2D
        @sign public Boolean/Array hit(String component)
        @param component - Component to check collisions for
        @return `false if no collision. If a collision is detected, return an Array of
        objects that are colliding, with the type of collision, and the contact points.
        The contact points has at most two points for polygon and one for circle.
        ~~~
        [{
          obj: [entity],
          type: "Box2D",
          points: [Vector[, Vector]]
        }]
      */

      hit: function(component) {
        var contactEdge, contactPoints, finalresult, manifold, otherEntity, otherId;
        contactEdge = this.body.GetContactList();
        if (!(contactEdge != null)) {
          return false;
        }
        otherId = contactEdge.other.GetUserData();
        otherEntity = Crafty(otherId);
        if (!otherEntity.has(component)) {
          return false;
        }
        if (!contactEdge.contact.IsTouching()) {
          return false;
        }
        finalresult = [];
        manifold = new b2WorldManifold();
        contactEdge.contact.GetWorldManifold(manifold);
        contactPoints = manifold.m_points;
        finalresult.push({
          obj: otherEntity,
          type: "Box2D",
          points: contactPoints
        });
        return finalresult;
      },
      /*
        #.onHit
        @comp Box2D
        @sign public this .onHit(String component, Function beginContact[, Function endContact])
        @param component - Component to check collisions for
        @param beginContact - Callback method to execute when collided with component, 
        @param endContact - Callback method executed once as soon as collision stops
        Invoke the callback(s) if collision detected through contact listener. We don't bind
        to EnterFrame, but let the contact listener in the Box2D world notify us.
      */

      onHit: function(component, beginContact, endContact) {
        var _this = this;
        if (component !== "Box2D") {
          return this;
        }
        this.bind("BeginContact", function(data) {
          var hitData;
          hitData = [
            {
              obj: Crafty(data.targetId),
              type: "Box2D",
              points: data.points
            }
          ];
          return beginContact.call(_this, hitData);
        });
        if (typeof endContact === "function") {
          this.bind("EndContact", function() {
            return endContact.call(_this);
          });
        }
        return this;
      }
    };
  })());

}).call(this);
